# <a name="S-glossary"></a>词汇表

这是在指导方针中用到的一些术语的相对非正式的定义
（基于 [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html) 中的词汇表）。

有关 C++ 的许多主题的更多信息，可以在[标准 C++ 基金会的网站](https://isocpp.org) 找到。

* *ABI*: 应用二进制接口，对于特定硬件平台与操作系统的组合的一种规范。与 API 相对。
* *抽象类（abstract class）*: 不能直接用于创建对象的类；通常用于为派生类定义接口。
  当类带有纯虚函数或只有受保护的构造函数时，它就是抽象的。
* *抽象（abstraction）*: 对事物的描述，有选择并有意忽略（隐藏）了细节（如实现细节）；选择性忽略。
* *地址（address）*: 用以在计算机的内存中找到某个对象的值。
* *算法（algorithm）*: 用以解决某个问题的过程或公式；有限的一系列计算步骤以产生一个结果。
* *别名（alias）*: 指代某个对象的替代方式；通常为名字，指针，或者引用。
* *API*: 应用编程接口，一组构成不同软件之间之间的交互的函数。与 ABI 相对。
* *应用程序（application）*: 程序或程序的集合，用户将其看作一个实体。
* *近似（approximation）*: 事物（比如值或者设计），接近于完美的或者理想的（值或设计）。
  通常近似都是在理想情形中进行各种权衡的结果。
* *参数/实参（argument）*: 传递给函数或模板的值，其中以形参来进行访问。
* *数组（array）*: 同质元素序列，通常是数值，例如 `[0:max)`。
* *断言（assertion）*: 插入到程序中的语句，以声称（断言）在程序的这个位置某事物必定为真。
* *基类（base class）*: 目的是为从其进行派生的类型（比如它带有非 `final` 的虚函数），且有意仅间接使用该类型的对象（如通过指针）。\[严格地说，“基类”可被定义为“从之进行派生的类型”，但我们这里以类设计者意图的角度来给出定义\] 通常基类带有一个或更多的虚函数。
* *位（bit）*: 计算机中信息的基本单位。一个位的值可以为 0 或 1。
* *bug*: 程序中的错误。
* *字节（byte）*: 大多数计算机中进行寻址的基本单位。通常一个字节有 8 位。
* *类（class）*: 一种用户定义的类型，可以包含数据成员，函数成员，以及成员类型。
* *代码（code）*: 程序或程序的部分；有歧义地同时用于源代码和目标代码。
* *编译器（compiler）*: 一种将源代码变为目标代码的程序。
* *复杂度（complexity）*: 对某个问题构造解决方案的难度，或解决方案自身的一种难于精确定义的记法或度量。
  有时候复杂度只是（简单地）表示对执行某个算法所需操作的数量的估计。
* *计算（computation）*: 执行一些代码，通常接受一些输入并产生一些输出。
* *概念（concept）*: (1) 提法，想法；(2) 一组要求，通常针对模板参数。
* *具体类（concrete type）*: 并非基类的类型，且有意直接使用该类型的对象（而非仅通过指针/间接），其大小是已知的，通常可以按程序员的意图在任何地方分配（比如静态地在运行栈上分配）。
* *常量（constant）*: （在给定作用域中）不能改变的值；不可变。
* *构造函数（constructor）*: 初始化（“构造”）一个对象的操作。
  通常构造函数会建立起不变式，并且通常会获取对象被使用时所需的资源（并通常将由析构函数所释放）。
* *容器（container）*: 持有一些元素（其他对象）的对象。
* *复制（copy）*: 制造两个对象使其值比较为相等的操作。另见移动。
* *正确性（correctness）*: 如果程序或程序片段符合其说明，则其为正确的。
  不幸的是，说明可能不完整或不一致，或者也可能无法满足用户的合理预期。
  因此为了产生可接受的代码，我们有时候比仅仅遵守形式说明要做更多的事。
* *成本（cost）*: 产生一个程序，或者执行它的耗费（如开发时间，执行时间或空间等）。
  理想情况下，成本应当是复杂度的函数。
* *定制点（customization point）*:
* *数据（data）*: 计算中所用到的值。
* *调试（debugging）*: 寻找并移除程序中的错误的行为；通常远没有测试那样系统化。
* *声明式（declaration）*: 程序中对一个名字及其类型的说明。
* *定义式（definition）*: 实体的声明式，提供了程序使用该实体所需的所有信息。
  简化版定义：分配了内存额声明。
* *派生类（derived class）*: 派生自一个或多个基类的类。
* *设计（design）*: 对软件的某个片段应当如何运作以满足其说明的一个总体描述。
* *析构函数（destructor）*: 当对象销毁（如在作用域结束时）被隐式执行（调用）的操作。它通常进行资源的释放。
* *封装（encapsulation）*: 将某些事物（如实现细节）保护为私有的，不接受未授权的访问。
* *错误（error）*: 对程序行为的合理期望（通常表现为某种需求或者一份用户指南）和程序的实际行为之间的不一致。
* *可执行程序（executable）*: 预备在计算机上运行（执行）的程序。
* *功能蔓延（feature creep）*: 为“预防万一”而向程序添加过量的功能的倾向。
* *文件（file）*: 计算机中的持久信息的容器。
* *浮点数（floating-point number）*: 计算机对实数（如 7.93 和 10.78e–3）的近似。
* *函数（function）*: 命名的代码单元，可以从程序的不同部分执行（调用）；计算的逻辑单元。
* *泛型编程（generic programming）*: 关注于算法的设计和高效实现的一种编程风格。
  泛型算法能够对所有符合其要求的参数类型正确工作。在 C++ 中，泛型编程通常使用模板进行。
* *全局变量（global variable）*: 技术上说，命名空间作用域中的具名对象。
* *句柄（handle）*: 一个类，允许通过一个成员指针或引用来访问另一个对象。另见资源，复制，移动。
* *头文件（header）*: 包含用于在程序的各个部分中共享接口的声明的文件。
* *隐藏（hiding）*: 防止一个信息片段被直接看到或访问的行为。
  例如，嵌套（内部）作用域中的名字会防止外部（外围）作用域中相同的名字被直接使用。
* *理想的（ideal）*: 我们力争达成的事物的完美版本。我们经常不得不进行各种权衡最后获得一个近似。
* *实现（implementation）*: (1) 编写代码并测试的活动；(2) 用以实现一个程序的代码。
* *无限循环（infinite loop）*: 终止条件永不为真的循环。参见重复。
* *无限递归（infinite recursion）*: 无法终止的递归，直到机器耗尽内存无法维持其调用。
  在现实中这种递归不可能是无限的，它会因某种硬件错误而终止。
* *信息隐藏（information hiding）*: 分离接口和实现，以此将用户不感兴趣的实现细节隐藏起来，并提供一种抽象的活动。
* *初始化（initialize）*: 为一个对象给定其第一个（初始）值。
* *输入（input）*: 计算中所使用的值（比如函数参数以及通过键盘所输入的字符）。
* *整数（integer）*: 整数，比如 42 和 –99。
* *接口（interface）*: 一个或一组声明，说明了一个代码片段（比如函数或者类）应当如何进行调用。
* *不变式（invariant）*: 程序中的某些点必然总为真的事物；通常用于描述对象的状态（值的集合），或者循环进入其重复的语句之前的状态。
* *重复（iteration）*: 重复执行代码片段的行为；参见递归。
* *迭代器（iterator）*: 用以标识序列中的一个元素的对象。
* *ISO*: 国际标准化组织。C++ 语言是一项 ISO 标准：ISO/IEC 14882。更多信息请参考 [iso.org](http://iso.org)。
* *程序库（library）*: 类型、函数、类等等的集合，它们实现了一组设施（抽象），预备可能被用作不止一个程序的组成部分。
* *生存期（lifetime）*: 从对象的初始化直到它变为不可用（离开作用域，被删除，或程序终止）的时间。
* *连接器（linker）*: 用以将目标代码文件和程序库合并构成一个可执行程序的程序。
* *字面量（literal）*: 直接指定一个值的写法，比如 12 指定的是整数值“十二”。
* *循环（loop）*: 重复执行的代码片段；在 C++ 中，通常是 `for` 语句或者 `while` 语句。
* *移动（move）*: 将值从一个对象转移到另一个对象，并遗留一个表示“空”的值的操作。另见复制。
* *仅可移动类型（move-only type）*：可以移动但不能复制的具体类型。
* *可变的（mutable）*: 可以改动；不可变、常量和不变量的反义词。
* *对象（object）*: (1) 已经初始化的一块具有已知类型的内存区域，持有该类型的一个值；(2) 一块内存区域。
* *目标代码（object code）*: 编译器的输出，预备作为连接器的输入（连接器以其产生可执行代码）。
* *目标文件（object file）*: 包含目标代码的文件。
* *面向对象编程（object-oriented programming）*: （OOP）一种关注类和类层次的设计和使用的编程风格。
* *操作（operation）*: 能够实施某种活动的事物，比如函数或运算符。
* *输出（output）*: 由计算所产生的值（例如函数的结果，或者在屏幕上写下的一行行字符等）。
* *溢出（overflow）*: 产生无法被其预期目标所存储的值。
* *重载（overload）*: 定义两个函数或运算符，使其具有相同名字但不同的参数（操作数）类型。
* *覆盖（override）*: 在派生类中用声明和基类中的某个虚函数具有相同名字和参数类型的函数，以此使该函数可以通过由基类所定义的接口来进行调用。
* *所有者（owner）*: 负责释放某个资源的对象。
* *范式（paradigm）*: 设计和编程风格的一种多少有些做作的术语；通常会被用于（错误地）暗示有一种范式被其他的都更优秀。
* *形参（parameter）*: 对函数或模板的一个明确输入的声明。当进行调用时，函数可以通过其形参的名字来访问向其所传递的各个实参。
* *指针（pointer）*: (1) 值，用于标识内存中的一个有类型的对象；(2) 持有这种值的变量。
* *后条件（post-condition）*: 当从一个代码片段（如函数或者循环）退出时必须满足的条件。
* *前条件（pre-condition）*: 当进入一个代码片段（如函数或者循环）时必须满足的条件。
* *程序（program）*: 足够完整以便能够在计算机上执行的代码（可能带有关联的数据）。
* *编程（programming）*: 将问题的解决方案表现为代码的工艺。
* *编程语言（programming language）*: 用于表达程序的语言。
* *伪代码（pseudo code）*: 以非正式的写法而非编程语言所编写的对计算的一种描述。
* *纯虚函数（pure virtual function）*: 必须在派生类中予以覆盖的虚函数。
* *RAII*: （“资源获取即初始化，Resource Acquisition Is Initialization”）一种基于作用域进行资源管理的基本技术。
* *范围（range）*: 值的序列，可以以一个开始点和一个结尾点进行描述。例如，`[0:5)` 的意思是值 0，1，2，3，和 4。
* *递归（recursion）*: 函数调用其自身的行为；另见重复。
* *引用（reference）*: (1) 一种值，描述内存中具有类型的值的位置；(2) 持有这种值的变量。
* *正则表达式（regular expression）*: 对字符串的模式的一种表示法。
* *正规*: 可以进行相等性比较的半正规类型（参见 `std::regular` 概念）。进行复制之后，副本对象与原对象比较为相等。正规类型的行为与如 `int` 这样的内建类型相似，且可以用 `==` 进行比较。
特别是，正规类型的对象可以进行复制，且复制的结果是与原对象比较为相等的一个独立对象。另见*半正规类型*。
* *要求（requirement）*: (1) 对程序或程序的一部分的预期行为的描述；(2) 对函数或模板对其参数所作出的假设的描述。
* *资源（resource）*: 获取而得的并随后必须被释放的事物，比如文件句柄，锁，或者内存。另见句柄，所有者。
* *舍入（rounding）*: 将一个值转换为某个较不精确类型的数学上最接近的值。
* *RTTI*: 运行时类型信息（Run-Time Type Information）。 ???
* *作用域（scope）*: 程序文本（源代码）的区域，在其中可以对一个名字进行涉指。
* *半正规（semiregular）*: 可复制的（也包括可移动的）且可默认构造的具体类型（参见 `std::semiregular` 概念）。复制的结果是一个与原对象具有相同的值的独立类型。半正规类型的行为与像 `int` 这样内建类型大致相似，但可能没有 `==` 运算符。另见*正规类型*。
* *序列（sequence）*: 可以以线性的顺序访问的一组元素。
* *软件（software）*: 代码片段及其关联数据的集合；通常可以和程序互换运用。
* *源代码（source code）*: 由程序员所生产的代码，（原则上）可以被其他程序员阅读。
* *源文件（source file）*: 包含源代码的文件。
* *规范（specification）*: 对代码片段应当做什么的描述。
* *标准（standard）*: 由官方承认的对某事物的定义，比如编程语言。
* *状态（state）*: 一组值。
* *STL*: 标准库中的容器，迭代器，以及算法部分。
* *字符串（string）*: 字符的序列。
* *风格（style）*: 旨在统一语言功能特征的使用的一组编程技巧；有时候以非常限定的方式来仅代表诸如命名和代码展现等的低层次规则。
* *子类型（subtype）*: 派生类型；一个类型具有另一个类型的所有（可能更多）的性质。
* *超类型（supertype）*: 基类型；一个类型具有另一个类型的性质的子集。
* *系统（system）*: (1) 用以在计算机上实施某种任务的一个或一组程序；(2) 对“操作系统”的简称，即计算机的基本执行环境及工具。
* *TS*: [技术规范](https://www.iso.org/deliverables-all.html type=ts)。技术规范所处理的是仍处于技术开发之中的工作，或者是认为这项工作以后可能会被同意采纳为国际标准，但并不会立即处理。技术规范的出版是为了其立即可用，也是为了提供一种获得反馈的方法。其目标是最终能够被转化并重新作为国际标准来出版。
* *模板（template）*: 由一个或多个的类型或（编译时）值进行参数化的类或函数；支持泛型编程的基本 C++ 语言构造。
* *测试（testing）*: 系统化地查找程序中的错误。
* *权衡（trade-off）*: 对多个设计和实现准则进行平衡的结果。
* *截断（truncation）*: 从一个类型转换为另一个无法精确表示被转换的值的类型时发生的信息损失。
* *类型（type）*: 为一个对象定义了一组可能的值和一组操作的事物。
* *未初始化的（uninitialized）*: 对象在初始化之前的（未定义的）状态。
* *单元（unit）*: (1) 为值赋予含义的一种标准度量（例如，距离单位 km）；(2) 较大的整体中的一个可区分的（比如命名的）部分。
* *用例（use case）*: 程序的某个特定（通常简化的）使用，以测试其功能并演示其目的。
* *值（value）*: 根据某个类型所解释的一组内存中的位。
* *值类型（value type）*：一些人用这个术语来表示正规或半正规类型。
* *变量（variable）*: 给定类型的具名对象；除非未初始化否则包含一个值。
* *虚函数（virtual function）*: 可在派生类中进行覆盖的成员函数。
* *字（word）*: 计算机中内存的基本单元，通常是用以持有一个整数的单元。

